#!/bin/sh
#
# This is based on the Git's pre-commit.sample.
#

no_unless_yes () {
	local input= code=$1 prompt=$2
	(
		# Personally, if STDERR is swallowed whole,
		# I wouldn't try talking to the terminal...
		#
		# Not that the following would be impossible,
		# but I'd be annoyed if my terminal hangs in-
		# definitely without a prompt in sight. :,]
		test -t 2 || exit $code
		if test -t 0; then
			exec 3<&0
		elif (exec </dev/tty) 2>/dev/null; then  # CAN I HAZ TTY???
			exec 3</dev/tty
		else
			echo >&2 You do not have a TTY, forsaken child. Goodbye.
			exit 255
		fi
		printf >&2 "%s [y/N] " "$prompt"
		read -u 3 -r input
		expr "$input" : '^y\|Y' >/dev/null || exit $code
		# XXX: Leave fd 3 open?
	)
}

ride_or_die () {
	local code=$1 mesg=$2
	printf >&2 "***** %s [code %s]\n" "$mesg" $code
	no_unless_yes $code "Would you like to continue?"
}

# Redirect output to stderr.
exec 1>&2

# Fatalize commands.
set -e

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	BASE=HEAD
else
	# Initial commit: diff against an empty tree object
	BASE=$(git hash-object -t tree /dev/null)
fi

# If there are whitespace errors, print the offending file names and fail.
git diff-index --check --cached $BASE -- || {
	ride_or_die $? "diff-index --check failed"
}

vnu_warn=0
vnu_path=

vnu ()
{
	if [ "$vnu_warn" -eq 1 ]; then
		return
	fi
	if ! {
		vnu_path="$(command -v validatornu)" ||
		vnu_path="$(command -v vnu)"
	} then
		echo >&2 "**** You don't have Nu Html Checker. Skipping HTML check."
		vnu_warn=1
		return
	fi

	"$vnu_path" "$@"
}

TMP=$(mktemp -d dinky-pcmit-XXXXXXXXX)
trap 'rm -rf "$TMP"' EXIT

git diff-index --cached --name-only --diff-filter=AM $BASE |
grep ^public/html/ | grep \\\.css\$\\\|\\\.html\$ | (
bad=0
while read -r file; do
	test="${file%.css}"
	if [ x"$file" != x"$test" ]; then
		flag='--css'
	fi
	vnu $flag "$file" || {
		code=$?
		echo >&2 "**** Nu check \"$file\" failed [code $code]"
		bad=$(( $bad+1 ))
	}
	[ "$vnu_warn" -ne 1 ] || break
done
echo $bad > $TMP/bad; )

bad=$(cat $TMP/bad)
if [ $bad -ne 0 ]; then
	cat <<OHNO >&2
**** A total of $bad Nu check$([ $bad -eq 1 ] || echo s) failed.
OHNO
	no_unless_yes $bad "Would you like to continue?"
fi
